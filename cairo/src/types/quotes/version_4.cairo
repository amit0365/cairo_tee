use cairo::types::quotes::header::QuoteHeader;
use cairo::types::quotes::body::QuoteBody;
use cairo::types::quotes::header::QuoteHeaderImpl;
use cairo::types::quotes::body::{EnclaveReportImpl, EnclaveReport};
use cairo::types::quotes::body::TD10ReportBodyImpl;
use cairo::constants::{ENCLAVE_REPORT_LEN, SGX_TEE_TYPE, TD10_REPORT_LEN, TDX_TEE_TYPE};
use cairo::types::quotes::{CertData, CertDataImpl};
use cairo::utils::byte::{felt252s_to_u8s, SpanU8TryIntoArrayU8Fixed2, SpanU8TryIntoArrayU8Fixed4,
    SpanU8TryIntoArrayU8Fixed96, SpanU8TryIntoArrayU8Fixed20, SpanU8TryIntoArrayU8Fixed28, 
    SpanU8TryIntoArrayU8Fixed16, SpanU8TryIntoArrayU8Fixed32, SpanU8TryIntoArrayU8Fixed64, 
    SpanU8TryIntoArrayU8Fixed60, SpanU8TryIntoArrayU8Fixed48, felt252s_to_u32, felt252s_to_u16, felt252s_to_u64};

#[derive(Drop, Copy)]
pub struct QuoteV4 {
    pub header: QuoteHeader,            // [48 bytes]
                                        // Header of Quote data structure.
                                        // This field is transparent (the user knows its internal structure).
                                        // Rest of the Quote data structure can be treated as opaque (hidden from the user).
    pub quote_body: QuoteBody,          // May either contain a SGX Enclave Report (384 bytes) or TD10 Report (584 bytes)
    pub signature_len: u32,             // [4 bytes]
                                        // Size of the Quote Signature Data structure in bytes.
    pub signature: QuoteSignatureDataV4,             // [variable bytes]
}

#[derive(Drop, Copy)]
pub struct QuoteSignatureDataV4 {
    pub quote_signature: [u8; 64],      // [64 bytes]
                                        // ECDSA signature, the r component followed by the s component, 2 x 32 bytes.
                                        // Public part of the Attestation Key generated by the Quoting Enclave.
    pub ecdsa_attestation_key: [u8; 64],// [64 bytes]
                                        // EC KT-I Public Key, the x-coordinate followed by the y-coordinate (on the RFC 6090 P-256 curve), 2 x 32 bytes.
                                        // Public part of the Attestation Key generated by the Quoting Enclave.
    pub qe_cert_data: CertData,         // [variable bytes]
                                        // QE Cert Data
}

trait QuoteSignatureDataV4FromBytes {
    fn from_bytes(raw_bytes: Span<felt252>) -> QuoteSignatureDataV4;
}

impl QuoteSignatureDataV4Impl of QuoteSignatureDataV4FromBytes {
    fn from_bytes(raw_bytes: Span<felt252>) -> QuoteSignatureDataV4 {
        let quote_signature = felt252s_to_u8s(raw_bytes.slice(0, 64)).try_into().unwrap();
        let ecdsa_attestation_key = felt252s_to_u8s(raw_bytes.slice(64, 64)).try_into().unwrap();
        let qe_cert_data = CertDataImpl::from_bytes(raw_bytes.slice(128, 128));

        QuoteSignatureDataV4 {
            quote_signature,
            ecdsa_attestation_key,
            qe_cert_data,
        }
    }
}

trait QuoteV4FromBytes {
    fn from_bytes(raw_bytes: Span<felt252>) -> QuoteV4;
}

impl QuoteV4Impl of QuoteV4FromBytes {
    fn from_bytes(raw_bytes: Span<felt252>) -> QuoteV4 {
        let header = QuoteHeaderImpl::from_bytes(raw_bytes.slice(0, 48));
        let mut offset: usize = 48;

        let quote_body = if header.tee_type == SGX_TEE_TYPE {
            offset += ENCLAVE_REPORT_LEN;
                QuoteBody::SGXQuoteBody(EnclaveReportImpl::from_bytes(raw_bytes.slice(48, offset - 48)))
        } else if header.tee_type == TDX_TEE_TYPE {
            offset += TD10_REPORT_LEN;
            QuoteBody::TD10QuoteBody(TD10ReportBodyImpl::from_bytes(raw_bytes.slice(48, offset - 48)))
        } else {
            panic!("Unknown TEE type")
        };

        let signature_len = felt252s_to_u32(raw_bytes.slice(offset, 4));
        offset += 4;
        let signature_slice = raw_bytes.slice(offset, signature_len);
        let signature = QuoteSignatureDataV4Impl::from_bytes(signature_slice);

        QuoteV4 {
            header,
            quote_body,
            signature_len,
            signature,
        }
    }
}

//     pub fn get_cert_data(&self) -> CertDataType {
//         match self.cert_data_type {
//             1 => CertDataType::Type1(self.cert_data.clone()),
//             2 => CertDataType::Type2(self.cert_data.clone()),
//             3 => CertDataType::Type3(self.cert_data.clone()),
//             4 => CertDataType::Type4(self.cert_data.clone()),
//             5 => CertDataType::CertChain(Certificates::from_pem(&self.cert_data)),
//             6 => CertDataType::QeReportCertData(QeReportCertData::from_bytes(&self.cert_data)),
//             7 => CertDataType::Type7(self.cert_data.clone()),
//             _ => CertDataType::Unused,
//         }
//     }
// }