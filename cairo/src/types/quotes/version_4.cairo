use cairo::types::quotes::header::QuoteHeader;
use cairo::types::quotes::body::QuoteBody;
use cairo::types::quotes::header::QuoteHeaderImpl;
use cairo::types::quotes::body::{EnclaveReportImpl, EnclaveReport};
use cairo::types::quotes::body::TD10ReportBodyImpl;
use cairo::types::cert::Certificates;
use cairo::constants::{ENCLAVE_REPORT_LEN, SGX_TEE_TYPE, TD10_REPORT_LEN, TDX_TEE_TYPE};

use cairo::utils::byte::{u32s_to_u8s, SpanU8TryIntoArrayU8Fixed2, SpanU8TryIntoArrayU8Fixed4,
    SpanU8TryIntoArrayU8Fixed96, SpanU8TryIntoArrayU8Fixed20, SpanU8TryIntoArrayU8Fixed28, 
    SpanU8TryIntoArrayU8Fixed16, SpanU8TryIntoArrayU8Fixed32, SpanU8TryIntoArrayU8Fixed64, 
    SpanU8TryIntoArrayU8Fixed60, SpanU8TryIntoArrayU8Fixed48, felt252s_to_u32, felt252s_to_u16, felt252s_to_u64};

#[derive(Drop, Copy)]
pub struct QuoteV4 {
    pub header: QuoteHeader,            // [48 bytes]
                                        // Header of Quote data structure.
                                        // This field is transparent (the user knows its internal structure).
                                        // Rest of the Quote data structure can be treated as opaque (hidden from the user).
    pub quote_body: QuoteBody,          // May either contain a SGX Enclave Report (384 bytes) or TD10 Report (584 bytes)
    pub signature_len: u32,             // [4 bytes]
                                        // Size of the Quote Signature Data structure in bytes.
    pub signature: QuoteSignatureDataV4,             // [variable bytes]
}

#[derive(Drop, Copy)]
pub struct QuoteSignatureDataV4 {
    pub quote_signature: [u8; 64],      // [64 bytes]
                                        // ECDSA signature, the r component followed by the s component, 2 x 32 bytes.
                                        // Public part of the Attestation Key generated by the Quoting Enclave.
    pub ecdsa_attestation_key: [u8; 64],// [64 bytes]
                                        // EC KT-I Public Key, the x-coordinate followed by the y-coordinate (on the RFC 6090 P-256 curve), 2 x 32 bytes.
                                        // Public part of the Attestation Key generated by the Quoting Enclave.
    pub qe_cert_data: CertData,         // [variable bytes]
                                        // QE Cert Data
}

#[derive(Drop, Copy)]
pub struct CertData {
    pub cert_data_type: u16,            // [2 bytes]
                                        // Determines type of data required to verify the QE Report Signature in the Quote Signature Data structure. 
                                        // 1 - (PCK identifier: PPID in plain text, CPUSVN, and PCESVN)
                                        // 2 - (PCK identifier: PPID encrypted using RSA-2048-OAEP, CPUSVN, and PCESVN)
                                        // 3 - (PCK identifier: PPID encrypted using RSA-2048-OAEP, CPUSVN, PCESVN, and QEID)
                                        // 4 - (PCK Leaf Certificate in plain text; currently not supported)
                                        // 5 - (Concatenated PCK Cert Chain)
                                        // 6 - (QE Report Certification Data)
                                        // 7 - (PLATFORM_MANIFEST; currently not supported)
    pub cert_data_size: u32,            // [4 bytes]
                                        // Size of Certification Data field.
    pub cert_data: Span<u8>,             // [variable bytes]
                                        // Data required to verify the QE Report Signature depending on the value of the Certification Data Type:
                                        // 1: Byte array that contains concatenation of PPID, CPUSVN, PCESVN (LE), PCEID (LE).
                                        // 2: Byte array that contains concatenation of PPID encrypted using RSA-2048-OAEP, CPUSVN, PCESVN (LE), PCEID (LE).
                                        // 3: Byte array that contains concatenation of PPID encrypted using RSA-3072-OAEP, CPUSVN, PCESVN (LE), PCEID (LE).
                                        // 4: PCK Leaf Certificate
                                        // 5: Concatenated PCK Cert Chain (PEM formatted). PCK Leaf Cert || Intermediate CA Cert || Root CA Cert 
                                        // 6: QE Report Certification Data
                                        // 7: PLATFORM_MANIFEST
}

trait CertDataFromBytes {
    fn from_bytes(raw_bytes: Span<felt252>) -> CertData;
}

impl CertDataImpl of CertDataFromBytes {
    fn from_bytes(raw_bytes: Span<felt252>) -> CertData {
        let cert_data_type = felt252s_to_u16(raw_bytes.slice(0, 2));
        let cert_data_size = felt252s_to_u32(raw_bytes.slice(2, 4));
        let cert_data = u32s_to_u8s(raw_bytes.slice(6, cert_data_size));

        CertData {
            cert_data_type,
            cert_data_size,
            cert_data,
        }
    }
}

trait QuoteSignatureDataV4FromBytes {
    fn from_bytes(raw_bytes: Span<felt252>) -> QuoteSignatureDataV4;
}

impl QuoteSignatureDataV4Impl of QuoteSignatureDataV4FromBytes {
    fn from_bytes(raw_bytes: Span<felt252>) -> QuoteSignatureDataV4 {
        let quote_signature = u32s_to_u8s(raw_bytes.slice(0, 64)).try_into().unwrap();
        let ecdsa_attestation_key = u32s_to_u8s(raw_bytes.slice(64, 64)).try_into().unwrap();
        let qe_cert_data = CertDataImpl::from_bytes(raw_bytes.slice(128, 128));

        QuoteSignatureDataV4 {
            quote_signature,
            ecdsa_attestation_key,
            qe_cert_data,
        }
    }
}

trait QuoteV4FromBytes {
    fn from_bytes(raw_bytes: Span<felt252>) -> QuoteV4;
}

impl QuoteV4Impl of QuoteV4FromBytes {
    fn from_bytes(raw_bytes: Span<felt252>) -> QuoteV4 {
        let header = QuoteHeaderImpl::from_bytes(raw_bytes.slice(0, 48));
        let mut offset: usize = 48;

        let quote_body = if header.tee_type == SGX_TEE_TYPE {
            offset += ENCLAVE_REPORT_LEN;
                QuoteBody::SGXQuoteBody(EnclaveReportImpl::from_bytes(raw_bytes.slice(48, offset - 48)))
        } else if header.tee_type == TDX_TEE_TYPE {
            offset += TD10_REPORT_LEN;
            QuoteBody::TD10QuoteBody(TD10ReportBodyImpl::from_bytes(raw_bytes.slice(48, offset - 48)))
        } else {
            panic!("Unknown TEE type")
        };

        let signature_len = felt252s_to_u32(raw_bytes.slice(offset, 4));
        offset += 4;
        let signature_slice = raw_bytes.slice(offset, signature_len);
        let signature = QuoteSignatureDataV4Impl::from_bytes(signature_slice);

        QuoteV4 {
            header,
            quote_body,
            signature_len,
            signature,
        }
    }
}

//     pub fn get_cert_data(&self) -> CertDataType {
//         match self.cert_data_type {
//             1 => CertDataType::Type1(self.cert_data.clone()),
//             2 => CertDataType::Type2(self.cert_data.clone()),
//             3 => CertDataType::Type3(self.cert_data.clone()),
//             4 => CertDataType::Type4(self.cert_data.clone()),
//             5 => CertDataType::CertChain(Certificates::from_pem(&self.cert_data)),
//             6 => CertDataType::QeReportCertData(QeReportCertData::from_bytes(&self.cert_data)),
//             7 => CertDataType::Type7(self.cert_data.clone()),
//             _ => CertDataType::Unused,
//         }
//     }
// }

pub enum CertDataType {
    Unused,
    Type1: Span<u8>,
    Type2: Span<u8>,
    Type3: Span<u8>,
    Type4: Span<u8>,
    CertChain: Certificates,
    QeReportCertData: QeReportCertData,
    Type7: Span<u8>,
}

#[derive(Copy, Drop)]
pub struct QeReportCertData {
    pub qe_report: EnclaveReport,
    pub qe_report_signature: [u8; 64],
    pub qe_auth_data: QeAuthData,
    pub qe_cert_data: CertData,
}

#[derive(Copy, Drop)]
pub struct QeAuthData {
    pub size: u16,
    pub data: Span<u8>,
}

trait QeAuthDataFromBytes {
    fn from_bytes(raw_bytes: Span<felt252>) -> QeAuthData;
}

impl QeAuthDataImpl of QeAuthDataFromBytes {
    fn from_bytes(raw_bytes: Span<felt252>) -> QeAuthData {
        let size = felt252s_to_u16(raw_bytes.slice(0, 2));
        let size_u32 = size.try_into().unwrap();
        let data = u32s_to_u8s(raw_bytes.slice(2, size_u32));
        QeAuthData {
            size,
            data,
        }
    }
}

trait QeReportCertDataFromBytes {
    fn from_bytes(raw_bytes: Span<felt252>) -> QeReportCertData;
}

impl QeReportCertDataImpl of QeReportCertDataFromBytes {
    fn from_bytes(raw_bytes: Span<felt252>) -> QeReportCertData {
        // 384 bytes for qe_report
        let qe_report = EnclaveReportImpl::from_bytes(raw_bytes.slice(0, 384));
        // 64 bytes for qe_report_signature
        let qe_report_signature = u32s_to_u8s(raw_bytes.slice(384, 64)).try_into().unwrap();
        // qe auth data is variable length, we'll pass remaining bytes to the from_bytes method
        let qe_auth_data = QeAuthDataImpl::from_bytes(raw_bytes.slice(448, raw_bytes.len() - 448));
        // get the length of qe_auth_data
        let qe_auth_data_size = 2 + qe_auth_data.size;
        // finish off with the parsing of qe_cert_data
        let qe_cert_data_start: u32 = (448 + qe_auth_data_size).try_into().unwrap();
        let qe_cert_data = CertDataImpl::from_bytes(raw_bytes.slice(qe_cert_data_start, raw_bytes.len() - qe_cert_data_start));

        QeReportCertData {
            qe_report,
            qe_report_signature,
            qe_auth_data,
            qe_cert_data,
        }
    }
}